

# 如何新增权限并用拦截器校验

## TL;DR（快速清单）

1. **确定权限码**（全大写+下划线）。
2. **写库表变更**：新增 `permission`，把它授给某些 `role`（`role_permission` 关系）。
3. **刷新权限缓存**（开发可重启；线上通过 `@CacheEvict` 或管理接口刷新）。
4. **加拦截规则**：在 `AppConfig.java` 的 `SecurityFilterChain` 里为接口写 `.hasAuthority("XXX")`。
5. （可选）**方法级**再加一层 `@PreAuthorize("hasAuthority('XXX')")`。
6. **自测**：带权限的 token 访问 200；不带权限 403（返回 `{code:"FORBIDDEN", message, status:403}`）。
7. **更新文档**：接口说明写明“需要权限：XXX”。

---

## 1) 命名规范

* 权限码：**常量风格**，如 `ORDER_PAY`, `INVITE_CREATE`, `SESSION_REVOKE_ALL`。
* 含义：单点且可复用的**动作**，不要混入资源 ID 等变量。

---

## 2) 数据层改动（新增权限 & 赋给角色）

你项目的数据模型：
`User` ⇢ `UserRole` ⇢ `Role` ⇢ `RolePermission` ⇢ `Permission(code)`

### 2.1 新增一条 `permission`

**Flyway 示例**：`src/main/resources/db/migration/V20250927__add_perm_order_refund.sql`

```sql
INSERT INTO permission (code, name, description)
VALUES ('ORDER_REFUND', '退款操作', '允许对订单执行退款');
```

### 2.2 授权给角色（例如 `ADMIN`）

```sql
-- 假设已有 ADMIN 角色
INSERT INTO role_permission (role_id, permission_id)
SELECT r.id, p.id
FROM role r, permission p
WHERE r.code = 'ADMIN' AND p.code = 'ORDER_REFUND';
```

> 如果你用 JPA/Seeder，也可以在初始化脚本里添加；关键是**权限码必须落表**，并且通过**角色-权限关系**授给用户。

---

## 3) 刷新权限缓存

你的用户权限是经由 **`PermissionCacheSpring`** 缓存出来的。改完数据库需刷新：

* **开发环境**：重启应用最快；
* **线上**：在更新角色/权限的服务方法上加 `@CacheEvict(cacheNames="permissionCache", allEntries=true)` 或提供一个管理端点触发刷新。

> 具体 cache 名以你 `CacheConfig`/`PermissionCacheSpring` 实际为准。

---

## 4) 在安全拦截器上启用校验（路径级）

在 **`AppConfig.java`**（或 `SecurityConfig`）的 `SecurityFilterChain` 配置里，给目标端口加 `.hasAuthority("ORDER_REFUND")`：

```java
@Bean
SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
      .csrf(csrf -> csrf.disable())
      .authorizeHttpRequests(auth -> auth
          // 公开端口
          .requestMatchers(
              "/api/v1/auth/login",
              "/api/v1/auth/refresh",
              "/api/v1/auth/signup/request-code",
              "/api/v1/auth/signup/confirm",
              "/api/v1/auth/invite/request-code",
              "/api/v1/auth/invite/confirm"
          ).permitAll()

          // 你的新权限（举例）
          .requestMatchers(HttpMethod.POST, "/api/v1/orders/{id}:refund").hasAuthority("ORDER_REFUND")

          // 已有的例子
          .requestMatchers(HttpMethod.POST, "/api/v1/auth/invite/request-code").hasAuthority("INVITE_CREATE")
          .requestMatchers(HttpMethod.POST, "/api/v1/auth/logout-all").hasAuthority("SESSION_REVOKE_ALL")

          .anyRequest().authenticated()
      );
    // 记得你的 JwtAuthFilter 在 UsernamePasswordAuthenticationFilter 之前
    // http.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
    return http.build();
}
```

> **顺序很重要**：更具体的 `requestMatchers` 写在前面，避免被更宽的匹配吞掉。

---

# 5不需要你做，理解就行

## 5) 认证链回顾（确认生效点）

* **`JwtAuthFilter`**：从 `Authorization: Bearer <accessToken>` 验签，读取 `userId/sid/ver`，
  调用：

  * `TokenVersionStoreSpring`（版本校验）
  * `SidBlacklistStoreSpring`（会话黑名单）
  * `PermissionCacheSpring`（拉取**权限码列表** → `GrantedAuthority`）
    将其放入 `SecurityContext`。
* **授权阶段**（`AuthorizationFilter`）：拿 `hasAuthority("ORDER_REFUND")` 与当前 `Authentication` 的 `authorities` 比对，成功放行，否则抛 `AccessDeniedException`（403）。

你无需改这条链，只要保证**新权限能被 `PermissionCacheSpring` 返回**即可。

---


---

## 6) 自测脚本

### 6.1 准备两枚 token

* **A（有权限）**：用户隶属包含 `ORDER_REFUND` 的角色；
* **B（无权限）**：普通用户。

### 6.2 调用

```bash
# 有权限 → 200
curl -i -X POST 'http://localhost:8080/api/v1/orders/123:refund' \
  -H 'Authorization: Bearer <TOKEN_A>' -H 'Content-Type: application/json' -d '{}'

# 无权限 → 403
curl -i -X POST 'http://localhost:8080/api/v1/orders/123:refund' \
  -H 'Authorization: Bearer <TOKEN_B>' -H 'Content-Type: application/json' -d '{}'
```

---

## 7) 变更后要更新的文档/代码位置

* `db/migration/*`：新增权限 & 角色关联脚本；
* `AppConfig.java`：`requestMatchers().hasAuthority("NEW_CODE")`；
* `PermissionCacheSpring`：若有缓存命中，需要刷新策略（`@CacheEvict`/管理接口/重启）；
* `docs/api/*`：在接口文档中注明“**需要权限：NEW_CODE**”；
* 前端：对 403 做文案 & 按钮显隐（例如：没有 `ORDER_REFUND` 不显示“退款”按钮）。

---

## 18) 常见排查

* ✅ 角色已关联新权限？（检查 `role_permission`）
* ✅ 缓存已刷新？（重启或 `@CacheEvict`）
* ✅ 规则写在更具体的匹配之前？（`requestMatchers` 顺序）
* ✅ `JwtAuthFilter` 确实把新权限放进了 `Authentication`？（在过滤器里临时 log `SecurityContextHolder.getContext().getAuthentication().getAuthorities()` 看看）
* ✅ 403 是否被 `GlobalExceptionHandler` 友好返回？（而不是默认白页）

