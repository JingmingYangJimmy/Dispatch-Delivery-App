**如何抛业务异常并携带 HTTP 状态**，以及**成功返回自动携带状态**（全局封装）。

---

# 错误与返回约定（含 status）

## 适用范围

* 后端框架：Spring Boot 3 / Spring Security 6
* 统一错误结构：`{code, message, status}`
* 统一成功结构（自动封装）：`{status, data}`

---

## 1) 业务异常：如何抛、如何返回

### 1.1 抛异常（BusinessException）

在任何业务/控制器里，使用三参构造携带状态：

```java
throw new BusinessException("LOGOUT_FAIL", "Logout identifier is invalid", HttpStatus.BAD_REQUEST);
```

**签名（已实现）：**

```java
public class BusinessException extends RuntimeException {
    private final String code;
    private final HttpStatus status;
    public BusinessException(String code, String message, HttpStatus status) { ... }
    public String getCode() { ... }
    public HttpStatus getStatus() { ... }
}
```

### 1.2 全局异常处理（GlobalExceptionHandler）

* 捕获 `BusinessException`，按统一结构输出：

```json
{ "code": "LOGOUT_FAIL", "message": "Logout identifier is invalid", "status": 400 }
```

* 兜底 `Exception` → `INTERNAL_ERROR 500`（同结构）。

> 说明：异常返回 **不** 会被成功封装再次包裹。

### 1.3 常见映射（建议）

| 场景           | code 示例                                        | HttpStatus |
| ------------ | ---------------------------------------------- | ---------- |
| 参数不合法/缺失     | `BAD_REQUEST`                                  | 400        |
| 未登录/令牌无效/过期  | `UNAUTHORIZED`/`INVALID_TOKEN`/`TOKEN_EXPIRED` | 401        |
| 无权限          | `FORBIDDEN`                                    | 403        |
| 资源不存在        | `NOT_FOUND`                                    | 404        |
| 冲突（重复/状态不允许） | `CONFLICT`/`EMAIL_IN_USE`                      | 409        |
| 频率限制         | `RATE_LIMITED`                                 | 429        |
| 服务器错误        | `INTERNAL_ERROR`                               | 500        |

**更多示例**

```java
throw new BusinessException("INVALID_TOKEN", "Refresh token is invalid", HttpStatus.UNAUTHORIZED);
throw new BusinessException("EMAIL_IN_USE", "This email is already registered", HttpStatus.CONFLICT);
throw new BusinessException("FORBIDDEN", "Access denied", HttpStatus.FORBIDDEN);
```

---

## 2) 成功返回：如何自动携带 `status`

### 2.1 全局封装器（ResponseBodyAdvice）

项目启用了全局封装器（`GlobalSuccessEnvelopeAdvice`），对**成功响应**自动包装为：

```json
{ "status": <httpStatus>, "data": <原始成功数据> }
```

**状态来源：**

* 若方法返回 `ResponseEntity`：取其 `status`。
* 否则取 Servlet 响应状态（默认 200）。
* `204 No Content` 不封装（无 body）。

**自动跳过的情况：**

* 错误体（含 `code` 和 `message`）
* 非 JSON 响应（文件、图片、纯文本等）
* 字符串、`byte[]`、`ResponseEntity`（部分场景）
* 显式使用 `@NoWrap` 注解的类/方法
* Swagger/Actuator 等内置端点

**跳过封装示例**

```java
@NoWrap
@GetMapping("/export")
public void exportCsv(...) { ... } // 文件下载不包
```

### 2.2 成功/失败对比示例

**成功（例如登录）**

```json
{
  "status": 200,
  "data": { "accessToken": "...", "refreshToken": "...", "expiresIn": 3600, "accessSid": "sid-..." }
}
```

**失败（例如 logout 标识无效）**

```json
{ "code": "LOGOUT_FAIL", "message": "Logout identifier is invalid", "status": 400 }
```

---

## 3) 前后端协作要点

### 3.1 前端读取

* 成功：从 `resp.data.status` 取状态码；从 `resp.data.data` 取业务数据。
* 失败：从 `resp.data.code`/`resp.data.message`/`resp.data.status` 读取错误信息与状态。

### 3.2 后端编写

* 成功：照常 `return` 业务对象或 `ResponseEntity`；**无需手动塞 `status` 字段**。
* 失败：统一用 `BusinessException(code, message, HttpStatus)` 抛出；**不要**返回 200 + 失败 code 的“伪成功”。

---

## 4) 迁移/回归检查清单

* [ ] 所有 `throw new BusinessException(code, message)` 已升级为**三参**版本并传入合适的 `HttpStatus`。
* [ ] `GlobalExceptionHandler` 输出体包含 `status`，且响应码使用 `ex.getStatus()`。
* [ ] 成功封装器启用：普通成功响应自动成为 `{"status", "data"}`。
* [ ] 对**非 JSON/文件下载/第三方回调**等已加 `@NoWrap` 或由封装器自动跳过。
* [ ] curl 自测：

  ```bash
  # 成功
  curl -i -X POST http://localhost:8080/api/v1/auth/login -H 'Content-Type: application/json' \
       -d '{"email":"user@example.com","password":"P@ssw0rd"}'
  # 失败
  curl -i -X POST http://localhost:8080/api/v1/auth/logout -H 'Content-Type: application/json' \
       -d '{"accessSid":"bad"}'
  ```

  预期分别为成功封装与错误统一结构。

---

## 5) FAQ

**Q1：成功响应的 `status` 会不会写死 200？**
不会。封装器按**真实 HTTP 状态**写入。返回 `ResponseEntity.status(201)` 时，封装结果是：

```json
{ "status": 201, "data": { ... } }
```

**Q2：错误响应会被二次封装吗？**
不会。封装器会检测到 `code/message` 键，直接放行，保持错误结构不变。

**Q3：我需要在成功 JSON 里自己加 `status` 吗？**
不需要。统一交给封装器；手写反而可能产生重复/不一致。

**Q4：怎么让某个接口不被封装？**
给方法或类加 `@NoWrap`，或返回非 JSON（如文件流）。封装器也会自动跳过 Swagger/Actuator。

---

## 6) 参考代码片段（便于定位）

* `exception/BusinessException.java`：三参带 `HttpStatus`
* `exception/GlobalExceptionHandler.java`：输出 `{code,message,status}`，设置 `ResponseEntity.status(ex.getStatus())`
* `web/NoWrap.java`：可跳过封装的注解
* `web/GlobalSuccessEnvelopeAdvice.java`：统一成功封装，正确解析 `ResponseEntity`/Servlet 状态，跳过错误体与非 JSON

---

如需，我可以把这份文档按你仓库结构拆分并补上具体包名/类名链接（如 `[BusinessException.java](../backend/src/main/java/...)`），或者生成一个“错误码对照表”初稿放到 `docs/api/error-codes.md`。
